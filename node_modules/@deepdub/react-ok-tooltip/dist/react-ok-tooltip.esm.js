import React, { useEffect, useState, useRef } from 'react';
import ReactDOM from 'react-dom';
import { usePopover, useArrowContainer } from 'react-tiny-popover';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var singletons = {};
function useSingleton(name) {
  useEffect(function () {
    if (singletons[name]) {
      throw new Error("Singletons can only be rendered once (rendering \"" + name + "\").");
    }

    singletons[name] = true;
    return function () {
      singletons[name] = false;
    };
  }, [name]);
}

var DEFAULT_DELAY = 1000;
var tooltipMethods = {};
var globalTooltipProps = {
  delay: DEFAULT_DELAY
};
function resetTooltipMethods() {
  Object.keys(tooltipMethods).forEach(function (key) {
    delete tooltipMethods[key];
  });
}
function initTooltipMethods(methods) {
  Object.assign(tooltipMethods, methods);
}
function setGlobalTooltipProps(props) {
  Object.assign(globalTooltipProps, props);
}

function createCssVarsForStyleProp(cssVars) {
  return cssVars;
}
function cx() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return args.filter(Boolean).join(' ');
}

var styles = {"tooltipContainer":"OkTooltip__tooltipContainer","arrow":"OkTooltip__arrow","content":"OkTooltip__content","title":"OkTooltip__title","subtitle":"OkTooltip__subtitle"};

function Tooltip(_temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      _ref$backgroundColor = _ref.backgroundColor,
      backgroundColor = _ref$backgroundColor === void 0 ? 'var(--color-black)' : _ref$backgroundColor,
      _ref$borderColor = _ref.borderColor,
      borderColor = _ref$borderColor === void 0 ? '#3a3a3a' : _ref$borderColor,
      _ref$arrowSize = _ref.arrowSize,
      arrowSize = _ref$arrowSize === void 0 ? 5 : _ref$arrowSize,
      _ref$delay = _ref.delay,
      delay = _ref$delay === void 0 ? DEFAULT_DELAY : _ref$delay,
      className = _ref.className,
      arrowClassName = _ref.arrowClassName;

  useSingleton('tooltip');

  var _useState = useState(false),
      tooltipVisible = _useState[0],
      setTooltipVisible = _useState[1];

  var _useState2 = useState({
    childRect: {},
    popoverRect: {},
    parentRect: {},
    boundaryRect: {},
    padding: 10,
    nudgedLeft: 0,
    nudgedTop: 0,
    boundaryInset: 10
  }),
      popoverState = _useState2[0],
      setPopoverState = _useState2[1];

  var childRef = useRef();

  var _usePopover = usePopover({
    childRef: childRef,
    positions: ['bottom'],
    align: 'center',
    padding: 10,
    reposition: true,
    boundaryInset: 0,
    parentElement: document.body,
    boundaryElement: document.body,
    onPositionPopover: setPopoverState
  }),
      positionPopover = _usePopover.positionPopover,
      popoverRef = _usePopover.popoverRef;

  var _useArrowContainer = useArrowContainer(_extends({}, popoverState, {
    arrowColor: backgroundColor,
    arrowSize: arrowSize
  })),
      arrowContainerStyle = _useArrowContainer.arrowContainerStyle,
      arrowStyle = _useArrowContainer.arrowStyle;

  useEffect(function () {
    initTooltipMethods({
      setPopperTooltipTriggerRef: function setPopperTooltipTriggerRef(ref) {
        childRef.current = ref != null ? ref : undefined;
      },
      setAppTooltipProps: function setAppTooltipProps(props) {
        var _props$maxWidth, _props$subtitle;

        if (!props || !contentRef.current || !titleRef.current || !subtitleRef.current) {
          return;
        }

        contentRef.current.style.maxWidth = (_props$maxWidth = props.maxWidth) != null ? _props$maxWidth : 'none';
        titleRef.current.innerText = props.title;
        subtitleRef.current.style.display = props.subtitle ? 'block' : 'none';
        subtitleRef.current.innerText = (_props$subtitle = props.subtitle) != null ? _props$subtitle : '';
      },
      setAppTooltipVisible: setTooltipVisible,
      popperTooltipUpdate: positionPopover
    });
    return function () {
      resetTooltipMethods();
    };
  }, [positionPopover]);
  useEffect(function () {
    setGlobalTooltipProps({
      delay: delay
    });
  }, [delay]);
  var contentRef = useRef(null);
  var titleRef = useRef(null);
  var subtitleRef = useRef(null);
  return ReactDOM.createPortal(React.createElement("div", {
    ref: popoverRef,
    className: cx(styles.tooltipContainer, className),
    style: _extends({
      visibility: tooltipVisible ? 'visible' : 'hidden'
    }, arrowContainerStyle, createCssVarsForStyleProp({
      '--arrow-size': arrowSize + "px",
      '--background-color': backgroundColor,
      '--border-color': borderColor
    }))
  }, React.createElement("div", {
    className: cx(styles.arrow, arrowClassName),
    style: arrowStyle
  }), React.createElement("div", {
    className: styles.content,
    ref: contentRef
  }, React.createElement("div", {
    className: styles.title,
    ref: titleRef
  }), React.createElement("div", {
    className: styles.subtitle,
    ref: subtitleRef
  }))), document.body);
}

var tooltipGroups = {};
function tooltipGroup(groupId) {
  return function (element) {
    var _groupId;

    (_groupId = groupId) != null ? _groupId : groupId = "tooltipGroup_" + Math.round(Math.random() * 100000).toString();

    function handleMouseOver(e) {
      tooltipGroups[groupId] = e.currentTarget;
    }

    if (!element) {
      return;
    }

    element.addEventListener('mouseover', handleMouseOver, {
      capture: true
    });
    element.dataset.okTooltipGroupId = groupId;
  };
}

var state = 'hidden';
var timeout;

function wait(callback, delay) {
  timeout = window.setTimeout(callback, delay);
}

function unwait() {
  clearTimeout(timeout);
}

function deferredShowTooltip(delay, showTooltip) {
  if (state === 'await-show') {
    return;
  }

  if (state === 'visible') {
    return;
  }

  if (state === 'await-hide' || state === 'hidden-grace') {
    unwait();
    state = 'visible';
    showTooltip();
  }

  if (state === 'hidden') {
    state = 'await-show';
    wait(function () {
      state = 'visible';
      showTooltip();
    }, delay);
  }
}
function deferredHideTooltip(hideTooltip) {
  if (state === 'await-show') {
    unwait();
    state = 'hidden';
  }

  if (state === 'visible') {
    state = 'await-hide';
    wait(function () {
      hideTooltip();
      state = 'hidden-grace';
      wait(function () {
        state = 'hidden';
      }, 500);
    }, 50);
  }

  if (state === 'await-hide') {
    return;
  }

  if (state === 'hidden-grace') {
    return;
  }

  if (state === 'hidden') {
    return;
  }
}

var _excluded = ["groupId"];
function tooltip(title, _temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      groupId = _ref.groupId,
      appTooltipProps = _objectWithoutPropertiesLoose(_ref, _excluded);

  return function (element) {
    function onMouseEnter(e) {
      var _element$closest;

      var wrappingGroupId = (_element$closest = element.closest('[data-ok-tooltip-group-id]')) == null ? void 0 : _element$closest.dataset.okTooltipGroupId; // If groupId is undefined, we fallback to wrappingGroupId.
      // If groupId === null, we want selectdGroupId to be null as well.
      // Otherwise (groupId is of type string), we use groupId.
      //

      var selectedGroupId = groupId === undefined ? wrappingGroupId : groupId;
      var triggerEl = selectedGroupId ? tooltipGroups[selectedGroupId] : element;
      tooltipMethods.setPopperTooltipTriggerRef == null ? void 0 : tooltipMethods.setPopperTooltipTriggerRef(triggerEl);
      tooltipMethods.setAppTooltipProps == null ? void 0 : tooltipMethods.setAppTooltipProps(_extends({
        title: title
      }, appTooltipProps));
      tooltipMethods.popperTooltipUpdate == null ? void 0 : tooltipMethods.popperTooltipUpdate();
      deferredShowTooltip(globalTooltipProps.delay, function () {
        return tooltipMethods.setAppTooltipVisible == null ? void 0 : tooltipMethods.setAppTooltipVisible(true);
      });
    }

    function onMouseLeave(e) {
      deferredHideTooltip(function () {
        return tooltipMethods.setAppTooltipVisible == null ? void 0 : tooltipMethods.setAppTooltipVisible(false);
      });
    }

    element == null ? void 0 : element.addEventListener('mouseenter', onMouseEnter);
    element == null ? void 0 : element.addEventListener('mouseleave', onMouseLeave);
  };
}

export { Tooltip as OkTooltip, tooltip, tooltipGroup };
//# sourceMappingURL=react-ok-tooltip.esm.js.map
